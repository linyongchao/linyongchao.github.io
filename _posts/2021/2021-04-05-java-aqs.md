---
layout: post
title:  AQS
date:   2021-04-06 01:49:05
categories: Java
---

* content
{:toc}

本文参考[这里](https://www.jianshu.com/p/b6388f2db2c0)  

## AQS

AQS(AbstractQueuedSynchronizer)抽象队列同步器是一个没有抽象方法的抽象类  
其内部维护一个 int 类型的 state 资源，另外维护一个 CLH 队列用于线程排队，CLH 队列本质上就是一个双向链表  
AQS使用了模板模式，内部定义了很多 final 修饰的方法作为模板，比如：

	public final void acquire(int arg)
	public final void acquireShared(int arg)
	public final boolean release(int arg)
	public final boolean releaseShared(int arg)

模板内部引用的如下其中五个方法是没有实现的：

    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean tryRelease(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected int tryAcquireShared(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean tryReleaseShared(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean isHeldExclusively() {
        throw new UnsupportedOperationException();
    }

## 源码

### 类结构

结合 ReentrantLock 类查看 AQS 源码，先看其类结构

![img](https://linyongchao.github.io/static/img/aqs/1.png)

最顶级的抽象类为 AOS(AbstractOwnableSynchronizer) ，其内部非常简单，用于记录独占模式下哪个线程持有锁

	public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
	
	    // 独占模式的当前所有者
	    private transient Thread exclusiveOwnerThread;
	
	    protected final void setExclusiveOwnerThread(Thread thread) {
	        exclusiveOwnerThread = thread;
	    }

	    protected final Thread getExclusiveOwnerThread() {
	        return exclusiveOwnerThread;
	    }
	}

次一级的抽象类就是要看的重点 AQS(AbstractQueuedSynchronizer)  
最后的 ReentrantLock 类中有三个静态内部类：  

1. Sync 是继承 AQS 的抽象类，其有一个抽象方法 lock()
2. FairSync 和 NonfairSync 是 Sync 的子类，分别实现公平锁和非公平锁

ReentrantLock 的构造方法有两个，默认是非公平锁，可以通过传参使用公平锁

    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    
### 加锁

ReentrantLock 使用 lock() 方法加锁，默认非公平锁实现如下：
    
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        final void lock() {
            // 通过CAS的方式加锁，加锁成功将state设置为1
            if (compareAndSetState(0, 1))
                // 加锁成功将对象独占线程设置为当前线程
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }

        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
    
非公平锁加锁步骤为：  

1. 通过CAS的方式加锁，加锁成功将state设置为1，其代码位于 AQS 中
	
	    protected final boolean compareAndSetState(int expect, int update) {
	        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
	    }

2. 加锁成功将对象独占线程设置为当前线程，其代码位于 AOS 中
3. 加锁失败执行方法：acquire(1); 其代码位于 AQS 中，是 final 方法，是 AQS 定义的模板

由下可见，acquire(1); 方法包含四个方法，依次看一下：

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
tryAcquire 方法在 AQS 内未实现，需要看子类，NonfairSync 内的 tryAcquire 则直接调用了父类 Sync 的 nonfairTryAcquire 方法

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
    
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        // 获取 state 的值
        int c = getState();
        if (c == 0) {
            // state = 0 说明无锁，无锁则通过 CAS 加锁，加锁成功设置当前线程为独占线程并返回成功
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            // 如果有锁，且是当前线程持有锁，则重入
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // 有锁且不是当前线程持有锁，则返回失败
        return false;
    }
    
1. 获取 state 的值，state 为 0 说明无锁，否则有锁
2. 无锁则通过 CAS 加锁，加锁成功设置当前线程为独占线程并返回成功
3. 有锁且是当前线程持有锁，则重入并返回成功
4. 有锁且不是当前线程持有锁，则返回失败

如果 tryAcquire 加锁失败，则先执行 addWaiter 方法，再执行 acquireQueued 方法  

addWaiter 方法：

	private Node addWaiter(Node mode) {
	    // 构造一个节点(EXCLUSIVE【独占】，SHARED【共享】)
	    Node node = new Node(Thread.currentThread(), mode);
	    Node pred = tail;
	    if (pred != null) {
	        // 队列的尾部节点不为空，则将构造的节点插入队列尾部
	        node.prev = pred;
	        if (compareAndSetTail(pred, node)) {
	            pred.next = node;
	            return node;
	        }
	    }
	    // 如果尾部节点为空或者插入失败，则执行 enq 方法
	    enq(node);
	    return node;
	}
	
    private Node enq(final Node node) {
        // 死循环，自旋
        for (;;) {
            Node t = tail;
            if (t == null) {
                // 如果尾部节点为空则初始化队列
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                // 尾部节点不为空，则将当前节点插入队列尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    
addWaiter +  enq 方法就初始化了一个队列，并且将当前线程添加到了队列中

然后是 acquireQueued 方法：

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                // 获取前级节点，如果为null，则抛异常
                final Node p = node.predecessor();
                // 如果前级节点是 head，则尝试抢锁
                if (p == head && tryAcquire(arg)) {
                    // 抢锁成功，将当前节点设置为新的 head
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 如果前级节点不为head，或者抢锁失败，则根据节点的状态决定是否需要挂起线程
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 如果获取锁异常，则取消获取锁操作
            if (failed)
                cancelAcquire(node);
        }
    }
    
	final Node predecessor() throws NullPointerException {
	    Node p = prev;
	    if (p == null)
	        throw new NullPointerException();
	    else
	        return p;
	}
	
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取前级节点的 waitStatus
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            // 如果前级节点的 waitStatus 为 SIGNAL(-1)，说明当前节点已经在等待唤醒了，所以直接返回true
            return true;
        if (ws > 0) {
            // 如果前级节点的 waitStatus > 0，说明已经取消，则向前遍历，直到找到节点状态不为取消的节点，然后将其设置为当前节点的前级节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            // 如果前级节点的 waitStatus = 0 或者不等于 -1 的 < 0 的值，则将当前节点的前级节点设置为 SIGNAL(-1)
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    
    // shouldParkAfterFailedAcquire 方法返回 true，则执行线程挂起
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
    
LockSupport 是 JDK1.6 开始提供的一个线程同步工具类，这里主要用其挂起线程和唤醒线程。  
LockSupport 的挂起和唤醒线程都是不可重入的，它有一个许可标志，当调用 park 时，会将许可设置为 0，挂起线程；如果再调用一次 park ，会阻塞线程。当调用 unpark 时才会将许可标志设置为 1  

    private static void setBlocker(Thread t, Object arg) {
        UNSAFE.putObject(t, parkBlockerOffset, arg);
    }

    public static void unpark(Thread thread) {
        if (thread != null)
            UNSAFE.unpark(thread);
    }

    public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }

### 非公平锁加锁总结

![img](https://linyongchao.github.io/static/img/aqs/2.png)

### 释放锁

ReentrantLock 的释放锁方法 unlock 调用了 AQS 的方法 release

    public void unlock() {
        sync.release(1);
    }
    
AQS 的 release 方法如下：

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            // 释放成功后，判断头节点的状态是否为无锁状态，如果不为无锁状态，则将头节点中的线程唤醒
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    
tryRelease 的实现位于 ReentrantLock 的抽象类 Sync 中，具体如下：
    
    protected final boolean tryRelease(int releases) {
        // 因为是重入锁，所以每释放一次减一
        int c = getState() - releases;
        // 释放资源的线程和持有锁的线程不一致，则抛异常
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            // 完全释放锁
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }    

释放锁成功后，唤醒线程的 unparkSuccessor 方法位于 AQS 中：

    private void unparkSuccessor(Node node) {
        // 获取节点的等待状态（此处由传参可知是头节点）
        int ws = node.waitStatus;
        if (ws < 0)
            // 将状态置为无锁状态
            compareAndSetWaitStatus(node, ws, 0);

        // 获取需要唤醒的下一个节点
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            // 如果下一个节点为空，或者已取消
            s = null;
            // 则从尾部向前找，直到找到一个未取消的节点
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            // 如果存在未取消的节点，则唤醒其线程
            LockSupport.unpark(s.thread);
    }
    
### 非公平锁释放总结

释放锁相对来说比较简单，所以流程比较简略

![img](https://linyongchao.github.io/static/img/aqs/3.png)

### 公平锁加锁

ReentrantLock 的公平锁和非公平锁在释放锁的逻辑上没有区别，均调用的 AQS 的模板 release 方法。二者的差异体现在加锁上，其加锁差异如下：

1. 非公平锁先尝试加锁，失败再执行 acquire：

        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
        
    公平锁直接 acquire

        final void lock() {
            acquire(1);
        }
        
2. 非公平锁在 tryAcquire 时如果 getState 为 0，则直接尝试加锁

            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }

    公平锁则先判断是否有前节点，没有才尝试加锁
        
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            
		   public final boolean hasQueuedPredecessors() {
		        Node t = tail;
		        Node h = head;
		        Node s;
		        // 当前线程不在头节点的下一个节点，说明其有前节点
		        return h != t &&
		            ((s = h.next) == null || s.thread != Thread.currentThread());
		    }

### 共享锁加锁

结合 CountDownLatch 看 AQS 的共享锁逻辑，由于和独占锁共享很多 AQS 中的方法，所以会比较简单  
CountDownLatch 内部有一个静态内部类 Sync，实现了 tryAcquireShared、tryReleaseShared 等方法  
CountDownLatch 的构造方法调用了静态内部类的构造方法，本质上就是给 AQS 的 state 赋值  

    // CountDownLatch 的构造方法调用了 Sync 的构造方法
    public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }

    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;

        // 给 AQS 中的 state 赋值
        Sync(int count) {
            setState(count);
        }

        int getCount() {
            return getState();
        }

        ……
    }
    
再来看加锁方法 await()，其调用了 AQS 的 acquireSharedInterruptibly 方法

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            // 如果线程中断，则抛异常
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            // 尝试获取资源失败，则进入自旋
            doAcquireSharedInterruptibly(arg);
    }
    
tryAcquireShared 位于静态内部类 Sync
    
    protected int tryAcquireShared(int acquires) {
        // 获取 state 值，值为 0 成功返回 1，失败返回 -1
        return (getState() == 0) ? 1 : -1;
    }
    
doAcquireSharedInterruptibly 位于 AQS 中
    
    private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        // 构造共享节点并加入队列
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // 前级节点是头节点，则尝试获取资源，失败则自旋
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        // 获取成功，则将head节点指向自己
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                // 判断是否需要挂起线程
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
setHeadAndPropagate 方法翻译为“设置头节点并传播”，其实就是在获取共享锁资源的时候，如果资源在唤醒一个节点后还有剩余，则继续唤醒后续的节点，直到资源被用完，体现了共享模式的共享。
    
    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        setHead(node);
        // 如果唤醒下一个节点后资源还有剩余，且新唤醒的节点不为无效状态，就继续唤醒队列中后续节点中的线程
        if (propagate > 0 || h == null || h.waitStatus < 0 || (h = head) == null || h.waitStatus < 0) {
            Node s = node.next;
            if (s == null || s.isShared())
                // 在释放锁一起解释
                doReleaseShared();
        }
    }
    
### 共享锁释放锁

CountDownLatch 的释放锁直接调用了 AQS 的模板

    public void countDown() {
        sync.releaseShared(1);
    }
    
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            // 释放锁成功后，唤醒节点
            doReleaseShared();
            return true;
        }
        return false;
    }

还是比较简单的，通过 CAS 释放锁，释放成功之后如果为0，说明释放成功

    protected boolean tryReleaseShared(int releases) {
        for (;;) {
            int c = getState();
            if (c == 0)
                // 释放锁却发现不需要释放，则返回失败
                return false;
            int nextc = c-1;
            if (compareAndSetState(c, nextc))
                // 释放成功且 state 为 0，则返回成功，否则失败
                return nextc == 0;
        }
    }
    
    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                // 如果头节点状态为等待唤醒，则将头节点的状态置为无锁状态，设置失败则自旋
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    // 唤醒头节点
                    unparkSuccessor(h);
                }
                // 如果头节点的状态已经为无锁状态了，那么将头节点的状态设置为传播唤醒状态
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }
    
