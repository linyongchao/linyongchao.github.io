---
layout: post
title:  AQS
date:   2021-04-06 01:49:05
categories: Java
---

* content
{:toc}

本文参考[这里](https://www.jianshu.com/p/b6388f2db2c0)  

## AQS

AQS(AbstractQueuedSynchronizer)抽象队列同步器是一个没有抽象方法的抽象类  
其内部维护一个 int 类型的 state 资源，另外维护一个 CLH 队列用于线程排队，CLH 队列本质上就是一个双向链表  
AQS使用了模板模式，内部定义了很多 final 修饰的方法作为模板，比如：

	public final void acquire(int arg)
	public final void acquireShared(int arg)
	public final boolean release(int arg)
	public final boolean releaseShared(int arg)

模板内部引用的如下其中五个方法是没有实现的：

    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean tryRelease(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected int tryAcquireShared(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean tryReleaseShared(int arg) {
        throw new UnsupportedOperationException();
    }
    
    protected boolean isHeldExclusively() {
        throw new UnsupportedOperationException();
    }

## 源码

### 类结构

结合 ReentrantLock 类查看 AQS 源码，先看其类结构

![img](https://linyongchao.github.io/static/img/aqs/1.png)

最顶级的抽象类为 AOS(AbstractOwnableSynchronizer) ，其内部非常简单，用于记录独占模式下哪个线程持有锁

	public abstract class AbstractOwnableSynchronizer implements java.io.Serializable {
	
	    // 独占模式的当前所有者
	    private transient Thread exclusiveOwnerThread;
	
	    protected final void setExclusiveOwnerThread(Thread thread) {
	        exclusiveOwnerThread = thread;
	    }

	    protected final Thread getExclusiveOwnerThread() {
	        return exclusiveOwnerThread;
	    }
	}

次一级的抽象类就是要看的重点 AQS(AbstractQueuedSynchronizer)  
最后的 ReentrantLock 类中有三个静态内部类：  

1. Sync 是继承 AQS 的抽象类，其有一个抽象方法 lock()
2. FairSync 和 NonfairSync 是 Sync 的子类，分别实现公平锁和非公平锁

ReentrantLock 的构造方法有两个，默认是非公平锁，可以通过传参使用公平锁

    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    
### 加锁

ReentrantLock 使用 lock() 方法加锁，默认非公平锁实现如下：
    
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        final void lock() {
            // 通过CAS的方式加锁，加锁成功将state设置为1
            if (compareAndSetState(0, 1))
                // 加锁成功将对象独占线程设置为当前线程
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }

        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
    
非公平锁加锁步骤为：  

1. 通过CAS的方式加锁，加锁成功将state设置为1，其代码位于 AQS 中
	
	    protected final boolean compareAndSetState(int expect, int update) {
	        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
	    }

2. 加锁成功将对象独占线程设置为当前线程，其代码位于 AOS 中
3. 加锁失败执行方法：acquire(1); 其代码位于 AQS 中，是 final 方法，是 AQS 定义的模板

由下可见，acquire(1); 方法包含四个方法，依次看一下：

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
tryAcquire 方法在 AQS 内未实现，需要看子类，NonfairSync 内的 tryAcquire 则直接调用了父类 Sync 的 nonfairTryAcquire 方法

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
    
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        // 获取 state 的值
        int c = getState();
        if (c == 0) {
            // state = 0 说明无锁，无锁则通过 CAS 加锁，加锁成功设置当前线程为独占线程并返回成功
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            // 如果有锁，且是当前线程持有锁，则重入
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // 有锁且不是当前线程持有锁，则返回失败
        return false;
    }
    
1. 获取 state 的值，state 为 0 说明无锁，否则有锁
2. 无锁则通过 CAS 加锁，加锁成功设置当前线程为独占线程并返回成功
3. 有锁且是当前线程持有锁，则重入并返回成功
4. 有锁且不是当前线程持有锁，则返回失败

如果 tryAcquire 加锁失败，则先执行 addWaiter 方法，再执行 acquireQueued 方法  

addWaiter 方法：

	private Node addWaiter(Node mode) {
	    // 构造一个节点(EXCLUSIVE【独占】，SHARED【共享】)
	    Node node = new Node(Thread.currentThread(), mode);
	    Node pred = tail;
	    if (pred != null) {
	        // 队列的尾部节点不为空，则将构造的节点插入队列尾部
	        node.prev = pred;
	        if (compareAndSetTail(pred, node)) {
	            pred.next = node;
	            return node;
	        }
	    }
	    // 如果尾部节点为空或者插入失败，则执行 enq 方法
	    enq(node);
	    return node;
	}
	
    private Node enq(final Node node) {
        // 死循环，自旋
        for (;;) {
            Node t = tail;
            if (t == null) {
                // 如果尾部节点为空则初始化队列
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                // 尾部节点不为空，则将当前节点插入队列尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    
addWaiter +  enq 方法就初始化了一个队列，并且将当前线程添加到了队列中

然后是 acquireQueued 方法：

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                // 获取前级节点，如果为null，则抛异常
                final Node p = node.predecessor();
                // 如果前级节点是 head，则尝试抢锁
                if (p == head && tryAcquire(arg)) {
                    // 抢锁成功，将当前节点设置为新的 head
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 如果前级节点不为head，或者抢锁失败，则根据节点的状态决定是否需要挂起线程
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 如果获取锁异常，则取消获取锁操作
            if (failed)
                cancelAcquire(node);
        }
    }
    
	final Node predecessor() throws NullPointerException {
	    Node p = prev;
	    if (p == null)
	        throw new NullPointerException();
	    else
	        return p;
	}
	
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取前级节点的 waitStatus
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            // 如果前级节点的 waitStatus 为 SIGNAL(-1)，说明当前节点已经在等待唤醒了，所以直接返回true
            return true;
        if (ws > 0) {
            // 如果前级节点的 waitStatus > 0，说明已经取消，则向前遍历，直到找到节点状态不为取消的节点，然后将其设置为当前节点的前级节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            // 如果前级节点的 waitStatus = 0 或者不等于 -1 的 < 0 的值，则将当前节点的前级节点设置为 SIGNAL(-1)
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    
    // shouldParkAfterFailedAcquire 方法返回 true，则执行线程挂起
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
    
LockSupport 是 JDK1.6 开始提供的一个线程同步工具类，这里主要用其挂起线程和唤醒线程。  
LockSupport 的挂起和唤醒线程都是不可重入的，它有一个许可标志，当调用 park 时，会将许可设置为 0，挂起线程；如果再调用一次 park ，会阻塞线程。当调用 unpark 时才会将许可标志设置为 1  

    private static void setBlocker(Thread t, Object arg) {
        UNSAFE.putObject(t, parkBlockerOffset, arg);
    }

    public static void unpark(Thread thread) {
        if (thread != null)
            UNSAFE.unpark(thread);
    }

    public static void park(Object blocker) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        UNSAFE.park(false, 0L);
        setBlocker(t, null);
    }

### 非公平锁加锁总结

![img](https://linyongchao.github.io/static/img/aqs/2.png)

### 释放锁

ReentrantLock 的释放锁方法 unlock 调用了 AQS 的方法 release

    public void unlock() {
        sync.release(1);
    }
    
AQS 的 release 方法如下：

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            // 释放成功后，判断头节点的状态是否为无锁状态，如果不为无锁状态，则将头节点中的线程唤醒
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    
tryRelease 的实现位于 ReentrantLock 的抽象类 Sync 中，具体如下：
    
    protected final boolean tryRelease(int releases) {
        // 因为是重入锁，所以每释放一次减一
        int c = getState() - releases;
        // 释放资源的线程和持有锁的线程不一致，则抛异常
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            // 完全释放锁
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }    

释放锁成功后，唤醒线程的 unparkSuccessor 方法位于 AQS 中：

    private void unparkSuccessor(Node node) {
        // 获取节点的等待状态（此处由传参可知是头节点）
        int ws = node.waitStatus;
        if (ws < 0)
            // 将状态置为无锁状态
            compareAndSetWaitStatus(node, ws, 0);

        // 获取需要唤醒的下一个节点
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            // 如果下一个节点为空，或者已取消
            s = null;
            // 则从尾部向前找，直到找到一个未取消的节点
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            // 如果存在未取消的节点，则唤醒其线程
            LockSupport.unpark(s.thread);
    }
    
### 非公平锁释放总结

释放锁相对来说比较简单，所以流程比较简略

![img](https://linyongchao.github.io/static/img/aqs/3.png)

### 公平锁加锁

ReentrantLock 的公平锁和非公平锁在释放锁的逻辑上没有区别，均调用的 AQS 的模板 release 方法。二者的差异体现在加锁上，其加锁差异如下：

1. 非公平锁先尝试加锁，失败再执行 acquire：

        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
        
    公平锁直接 acquire

        final void lock() {
            acquire(1);
        }
        
2. 非公平锁在 tryAcquire 时如果 getState 为 0，则直接尝试加锁

            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }

    公平锁则先判断是否有前节点，没有才尝试加锁
        
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            
		   public final boolean hasQueuedPredecessors() {
		        Node t = tail;
		        Node h = head;
		        Node s;
		        // 当前线程不在头节点的下一个节点，说明其有前节点
		        return h != t &&
		            ((s = h.next) == null || s.thread != Thread.currentThread());
		    }
